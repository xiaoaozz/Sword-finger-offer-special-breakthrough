#### [剑指 Offer II 003. 前 n 个数字二进制中 1 的个数](https://leetcode.cn/problems/w3tCBm/)

给定一个非负整数 n ，请计算 0 到 n 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。

 

示例 1:

```
输入: n = 2
输出: [0,1,1]
解释: 
0 --> 0
1 --> 1
2 --> 10
```


示例 2:

```
输入: n = 5
输出: [0,1,1,2,1,2]
解释:
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```


说明 :

```
0 <= n <= 105
```

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/w3tCBm
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



> 解法一：Brian Kernighan 算法
>
> 高效求二进制中1的个数的算法，这种方法比较容易理解
>
> 我们要计算的数与该数减一的 进行&运算，当计算结果为0时，程序结束。
> 例如，让7（111）&6（110）得到的是6（110），接着6（110）&5（101）得到4（100），接着4（100）&3（011）得到0（000），程序结束，得到的结果就是有3个“1”

```java
class Solution {
    public int[] countBits(int n) {
        // 返回的数组，存放所有的结果
        int[] res = new int[n + 1];
        // 全局变量，循环利用，减少内存使用
        int value = 0;
        int temp = 0;
        for(int i = 0; i <= n; i++) {
            temp = i;
            while(temp > 0) {
                // 利用数字之间的关系进行快速运算、
                // 这里不能使用判断 temp & 1 == 1的方式来判断，会超时
                temp = temp & (temp - 1);
                value++;
            }
            res[i] = value;
            value = 0;
        }
        return res;
    }
}
```

